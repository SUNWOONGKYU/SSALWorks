# 1편 | SAL Grid 개요와 핵심 개념

---

SAL Grid는 AI와의 협업을 위해 설계된 프로젝트 관리 시스템이다. 3차원 좌표 구조(SAL)와 22개 속성 격자(Grid)의 결합으로, 모호함 없는 명확한 작업 정의와 추적이 가능하다.

## 1. 왜 SAL Grid인가

### AI와 협업의 현실적 어려움

AI와 함께 프로젝트를 진행해본 경험이 있다면, 다음과 같은 상황이 익숙할 것이다.

**모호함의 문제**

```
사람: "그 로그인 관련 백엔드 작업 있잖아, 그거 해줘"
AI: "로그인 관련 백엔드 작업이 여러 개 있는데, 어떤 것을 말씀하시나요?"
사람: "아니 그거... 지난번에 얘기했던 거"
AI: "세션이 새로 시작되어서 이전 대화 내용을 알 수 없습니다"
```

**컨텍스트 손실**

AI 세션이 끊어지면 이전에 무엇을 했는지, 다음에 무엇을 해야 하는지 모두 사라진다. 매번 처음부터 상황을 설명해야 하고, 그 과정에서 중요한 맥락이 누락되기도 한다.

**순서 혼란**

"이거 먼저 해야 하나, 저거 먼저 해야 하나?" AI가 스스로 판단하기 어렵다. 의존 관계가 명시되어 있지 않으면, 선행 작업이 완료되지 않은 상태에서 후속 작업을 시작하는 실수가 발생한다.

### 해결책: 체계화된 구조

이 문제들의 공통점은 **구조화의 부재**이다. 자연어로 주고받는 대화는 사람에게는 자연스럽지만, AI에게는 모호함의 원천이다.

SAL Grid는 이 문제를 해결하기 위해 탄생했다.

- **좌표 체계**: 모든 작업에 고유한 3차원 좌표를 부여
- **속성 격자**: 각 작업에 22개의 명시적 속성을 정의
- **구조화된 데이터**: AI가 파싱하고 처리하기 쉬운 형태

"S2BA1 작업해줘"라고 하면, AI는 정확히 어떤 작업인지 즉시 파악한다. Stage 2, Backend APIs, Level 1. 오해의 여지가 없다.

---

## 2. SAL: 3차원 좌표 구조

SAL은 **S**(Stage) + **A**(Area) + **L**(Level)의 약자이다. 프로젝트의 모든 작업을 3차원 공간에 배치하는 좌표 체계이다.

### 2.1 왜 3차원인가

프로젝트의 작업은 본질적으로 3차원적 특성을 갖는다.

- **시간적 흐름**: 개발 준비 → 개발 → 테스트 → 배포 (Stage)
- **기술적 분류**: 프론트엔드, 백엔드, DB, 보안 등 (Area)
- **작업 순서**: 같은 영역 내에서 1번, 2번, 3번 순서 (Level)

이 세 가지 축을 조합하면 프로젝트 내 모든 작업의 위치를 정확히 특정할 수 있다. 마치 건물에서 "3층 201호"라고 하면 정확한 위치를 알 수 있는 것과 같다.

### 2.2 S (Stage) - 개발 단계

Stage는 프로젝트의 시간적 진행 단계를 나타낸다. X축에 해당한다.

| Stage | 이름 | 설명 |
|-------|------|------|
| S1 | 개발 준비 | 환경 설정, 인증 구성, DB 스키마 |
| S2 | 개발 1차 | 핵심 기능 구현 |
| S3 | 개발 2차 | 고급 기능 구현 |
| S4 | 개발 3차 | QA, 최적화 |
| S5 | 운영 | 배포, 모니터링 |

Stage는 순차적이다. S1이 완료되어야 S2로 넘어갈 수 있다. 이것이 Stage Gate라는 개념으로 연결된다.

### 2.3 A (Area) - 개발 영역

Area는 작업의 기술적 영역을 나타낸다. Y축에 해당한다.

| 코드 | Area | 설명 |
|------|------|------|
| F | Frontend | 화면, UI/UX |
| BA | Backend APIs | 서버 API |
| BI | Backend Infra | 공통 라이브러리 |
| D | Database | 데이터베이스 |
| S | Security | 인증, 인가 |
| E | External | 외부 연동 |
| T | Testing | 테스트 |
| O | DevOps | 배포, 운영 |
| M | Documentation | 문서화 |
| U | Design | UI/UX 디자인 |
| C | Content | 콘텐츠 시스템 |

Area는 병렬적이다. 같은 Stage 내에서 Frontend와 Backend를 동시에 진행할 수 있다.

### 2.4 L (Level) - 작업 순서

Level은 같은 Stage, 같은 Area 내에서의 작업 순서를 나타낸다. Z축에 해당한다.

```
S2BA1 → S2BA2 → S2BA3
  ↓
Level 1, 2, 3... 순서대로 진행
```

Level은 단순한 숫자이다. 1, 2, 3... 순서대로 작업한다.

### 2.5 Task ID = 3D 좌표

Task ID는 3차원 좌표 그 자체이다.

```
S2BA1
│ │ └─ Level: 1 (첫 번째 작업)
│ └─── Area: BA (Backend APIs)
└───── Stage: S2 (개발 1차)
```

이 ID 하나로 프로젝트 내 정확한 위치를 특정할 수 있다.

---

## 3. 공간적 참조성

3차원 좌표 체계의 강력한 점은 **공간적 참조성**이다. 좌표 간의 관계를 통해 의존성, 병렬성, 인접성을 파악할 수 있다.

### 의존성 (Dependency)

한 작업이 다른 작업의 완료를 필요로 하는 관계이다.

```
S1D1 (DB 스키마) → S2BA1 (API 구현)
                      ↑
         DB 스키마가 있어야 API 구현 가능
```

좌표를 보면 의존 관계가 명확하다. S1(개발 준비)의 Database 작업이 S2(개발 1차)의 Backend API보다 먼저 완료되어야 한다.

### 병렬성 (Parallelism)

같은 Stage 내에서 동시에 진행 가능한 작업들이다.

```
S2F1 (Frontend 로그인 UI)  ←┐
S2BA1 (Backend 로그인 API) ←┼── 동시 진행 가능
S2S1 (Security 인증 설정)  ←┘
```

Stage가 같으면 병렬 진행이 가능하다. Area가 다르므로 서로 충돌하지 않는다.

### 인접성 (Adjacency)

좌표가 가까운 작업들은 관련성이 높다.

```
S2BA1과 S2BA2 → 같은 Stage, 같은 Area, Level만 다름
              → 연속 작업, 높은 관련성

S2BA1과 S4T1 → Stage도 다르고 Area도 다름
              → 관련성 낮음
```

맨하탄 거리(좌표 차이의 합)가 가까울수록 관련성이 높다고 판단할 수 있다.

---

## 4. Grid: 22개 속성 격자

### 4.1 좌표만으로는 부족하다

3차원 좌표는 작업의 **위치**를 알려준다. 하지만 그 작업이 **무엇인지**, **어떻게 해야 하는지**, **누가 하는지**는 알려주지 않는다.

```
S2BA1 = Stage 2, Backend APIs, Level 1

→ 위치는 알겠는데...
→ 구체적으로 뭘 해야 하지?
→ 어떻게 검증하지?
→ 선행 작업은 뭐지?
```

이 정보를 담기 위해 **Grid**가 필요하다.

### 4.2 22개 속성의 역할

Grid는 각 Task에 22개의 속성을 부여한다. 주요 속성을 살펴보면:

**기본 정보**
- `task_id`: 3D 좌표 (예: S2BA1)
- `task_name`: 작업 이름
- `stage`, `area`, `level`: 좌표 분해값

**실행 정보**
- `task_instruction`: 무엇을 해야 하는지
- `task_agent`: 어떤 Agent가 수행하는지
- `dependencies`: 선행 작업 목록

**상태 정보**
- `status`: 대기/진행/완료
- `progress`: 진행률 (0~100)
- `blockers`: 차단 요소

**검증 정보**
- `verification_instruction`: 어떻게 검증하는지
- `verification_agent`: 누가 검증하는지
- `test_result`: 테스트 결과

이 속성들이 격자(Grid) 형태로 정리되어, 모든 Task의 상태를 한눈에 파악할 수 있다.

### 4.3 좌표 + 속성 = 완전한 Task 정의

SAL(좌표)과 Grid(속성)가 결합되면, 작업이 완전히 정의된다.

```
Task: S2BA1
├── 좌표: Stage 2, Backend APIs, Level 1
└── 속성:
    ├── task_name: "구독 취소 API"
    ├── task_instruction: "POST /api/subscription/cancel 구현"
    ├── dependencies: ["S1D1", "S1S1"]
    ├── task_agent: "backend-developer"
    ├── verification_instruction: "API 호출 시 구독 상태 변경 확인"
    └── verification_agent: "code-reviewer"
```

이제 AI는 이 정보만 보고 작업을 수행할 수 있다. 추가 설명이 필요 없다.

---

## 5. AI 협업이 가능해지는 이유

SAL Grid가 AI 협업에 최적화된 이유를 정리하면 다음과 같다.

### 명확한 좌표 = 모호함 제거

```
❌ "그 로그인 관련 백엔드 작업"
✅ "S2BA1"
```

Task ID 하나로 정확한 위치를 특정한다. "어떤 작업이요?"라는 질문이 사라진다.

### 구조화된 속성 = 명시적 지시

```
task_instruction: "POST /api/subscription/cancel 구현"
verification_instruction: "API 호출 시 구독 상태 변경 확인"
```

자연어로 장황하게 설명할 필요 없이, 구조화된 필드에서 필요한 정보를 읽는다. AI가 JSON으로 바로 파싱하고 처리할 수 있다.

### 세션 끊어져도 연속성 유지

```
AI 세션 새로 시작
    ↓
Grid 읽기
    ↓
현재 상태 파악: S2BA1 진행 중, 70% 완료, blocker 없음
    ↓
이어서 작업
```

Grid에 모든 상태가 기록되어 있으므로, 세션이 끊어져도 처음부터 다시 설명할 필요가 없다.

### 의존성/순서 자동 판단

```
dependencies: ["S1D1", "S1S1"]
    ↓
AI: "S1D1과 S1S1이 완료되었는지 먼저 확인하겠습니다"
```

선행 작업이 명시되어 있으므로, AI가 스스로 순서를 판단한다.

---

## 6. 다음 단계

1편에서는 SAL Grid의 전체 개념을 살펴봤다.

- **SAL**: 3차원 좌표 (Stage × Area × Level)
- **Grid**: 22개 속성 격자
- **목적**: AI와의 체계적 협업

다음 편에서는 각 구성 요소를 더 자세히 살펴본다.

- **2편**: Stage 상세 - 5개 Stage와 Stage Gate
- **3편**: Area 상세 - 11개 Area와 역할
- **4편**: Level과 Task ID 명명 규칙
- **5편**: 22개 속성 완전 가이드

---

*다음 편: 2편 | Stage 상세와 Stage Gate*

---

**작성일: 2025-12-20 / 글자수: 약 4,800자 / 작성자: Claude / 프롬프터: 써니**
