# 4편 | Task 생성과 의존성 관리

---

SAL Grid에서 프로젝트는 Task들의 집합이다. Task를 어떻게 나누고, 어떤 순서로 연결하느냐에 따라 프로젝트의 성패가 결정된다. 이 편에서는 Task를 생성하고 의존성을 관리하는 방법을 살펴본다.

## 1. Task 분할의 원칙

### 적절한 Task 크기

Task는 너무 크지도, 너무 작지도 않아야 한다. 이상적인 Task는 다음 조건을 만족한다.

**좋은 Task의 조건**:
1. **단일 책임**: 하나의 명확한 목표를 가진다
2. **독립 테스트**: 다른 Task 없이도 테스트할 수 있다
3. **명확한 완료 기준**: 완료 여부를 객관적으로 판단할 수 있다
4. **하나의 결과물**: 명확한 산출물이 있다

### 너무 크면?

```
❌ 잘못된 예: "인증 시스템 전체 구현"

문제점:
- 범위가 모호하다
- 완료 기준이 불명확하다
- 테스트하기 어렵다
- 진행률 파악이 어렵다
```

### 너무 작으면?

```
❌ 잘못된 예: "버튼 색상 변경"

문제점:
- Task 수가 폭증한다
- 관리 오버헤드가 증가한다
- 의존성 관리가 복잡해진다
```

### 올바른 분할 예시

큰 기능을 적절한 크기의 Task로 분할하는 예시:

```
[큰 기능: 사용자 인증 시스템]
    ↓ 분할

├── S1D1: users 테이블 스키마
├── S1S1: Supabase Auth 설정
├── S2F1: 로그인 UI
├── S2F2: 회원가입 UI
├── S2BA1: 로그인 API
├── S2BA2: 회원가입 API
└── S2S1: 세션 관리
```

각 Task가 독립적으로 테스트 가능하고, 명확한 완료 기준이 있다.

### 분할 기준 체크리스트

| 기준 | 좋은 예 | 나쁜 예 |
|------|---------|---------|
| 단일 책임 | "로그인 API 구현" | "인증 시스템 전체" |
| 독립 테스트 | Task만으로 테스트 가능 | 다른 Task 완료 필요 |
| 명확한 완료 | "API가 200 반환" | "기능이 잘 동작함" |
| 결과물 | "login.js 파일" | "여러 파일 수정" |

---

## 2. Task ID 부여 규칙

### 기본 구조

Task ID = Stage + Area + Level

```
S2BA1
│ │ └─ Level: 1 (해당 Stage-Area의 첫 번째 Task)
│ └─── Area: BA (Backend APIs)
└───── Stage: S2 (개발 1차)
```

### Level 결정 방법

같은 Stage, 같은 Area 내에서 작업 순서대로 Level을 부여한다.

```
S2BA1: 구독 관리 API (먼저)
S2BA2: 이메일 발송 API (나중)
S2BA3: 알림 설정 API (더 나중)
```

**주의**: Level은 의존성 순서가 아니다. 단순히 같은 칸 안에서의 작업 순서이다.

### ID 부여 예시

| 기능 | Stage | Area | Level | Task ID |
|------|-------|------|-------|---------|
| users 테이블 | S1 | D | 1 | S1D1 |
| subscriptions 테이블 | S1 | D | 2 | S1D2 |
| Google 로그인 UI | S2 | F | 1 | S2F1 |
| 이메일 인증 UI | S2 | F | 2 | S2F2 |
| 구독 취소 API | S2 | BA | 1 | S2BA1 |

### 명명 규칙 요약

1. Stage는 항상 S1~S5
2. Area는 정해진 11개 코드만 사용
3. Level은 1부터 순차적으로 증가
4. 중간에 Task 추가 시 새 Level 부여 (S2BA1.5 같은 형태 금지)

---

## 3. 의존성 설정

### dependencies 속성

Task가 시작하기 전에 완료되어야 하는 선행 Task를 명시한다.

```json
{
  "task_id": "S2BA1",
  "task_name": "구독 관리 API",
  "dependencies": ["S1D1", "S1S1"]
}
```

**의미**: S2BA1을 시작하려면 S1D1(DB 스키마)과 S1S1(Auth 설정)이 먼저 완료되어야 한다.

### 의존성 유형

**1. 데이터 의존성**

```
S1D1 (users 테이블) → S2BA1 (사용자 API)
                          ↑
         테이블이 있어야 API 구현 가능
```

**2. 기능 의존성**

```
S2BA1 (구독 API) → S2F1 (구독 UI)
                       ↑
         API가 있어야 UI에서 호출 가능
```

**3. 설정 의존성**

```
S1S1 (Auth 설정) → S2S1 (세션 관리)
                       ↑
         Auth가 설정되어야 세션 관리 가능
```

### 의존성 표기 규칙

1. **직접 의존성만 명시**: A→B→C일 때 C는 B만 명시 (A는 암묵적)
2. **명확한 이유**: 왜 의존하는지 알 수 있어야 함
3. **최소화**: 불필요한 의존성은 병렬 작업을 막는다

```
✅ 좋은 예:
S2BA1: dependencies: ["S1D1"]  // DB 스키마 필요

❌ 나쁜 예:
S2BA1: dependencies: ["S1D1", "S1D2", "S1D3", "S1S1", "S1BI1"]
// 정말 다 필요한가?
```

---

## 4. 순환 의존성 방지

### 순환 의존성이란?

A가 B에 의존하고, B가 다시 A에 의존하는 상태. 이러면 어떤 Task도 시작할 수 없다.

```
❌ 순환 의존성 (금지!)

S2F1 → S2BA1 → S2F1
  ↑               │
  └───────────────┘

"UI가 API 필요" + "API가 UI 필요" = 교착 상태
```

### 발견 방법

1. **의존성 다이어그램 작성**: 화살표가 원을 그리면 순환
2. **Stage 확인**: 같은 Stage 내 상호 의존은 위험 신호
3. **AI 검증**: Grid 생성 시 순환 의존성 자동 검사

### 해결 방법

**1. Task 분할**

```
문제:
S2F1 (로그인 UI) ↔ S2BA1 (로그인 API)

해결:
S2BA1: 로그인 API (의존성 없음)
S2F1: 로그인 UI (dependencies: ["S2BA1"])
```

**2. 인터페이스 분리**

```
문제:
Frontend ↔ Backend 상호 의존

해결:
S1M1: API 명세 정의 (의존성 없음)
S2BA1: API 구현 (dependencies: ["S1M1"])
S2F1: UI 구현 (dependencies: ["S1M1"])

→ 둘 다 명세에만 의존, 서로 의존 안 함
```

**3. 단방향으로 재설계**

대부분의 경우, 의존성은 단방향으로 정리할 수 있다:
- DB → Backend → Frontend
- 설정 → 기능 → UI

---

## 5. Task Plan 작성

### Task Plan이란?

프로젝트의 모든 Task를 정리한 문서. 전체 작업 목록과 의존성을 한눈에 볼 수 있다.

### 작성 형식

```markdown
# Task Plan

## S1: 개발 준비

| Task ID | Task Name | Dependencies | Status |
|---------|-----------|--------------|--------|
| S1D1 | users 테이블 | - | 완료 |
| S1D2 | subscriptions 테이블 | S1D1 | 완료 |
| S1S1 | Auth 설정 | - | 완료 |
| S1BI1 | Supabase Client | S1S1 | 완료 |

## S2: 개발 1차

| Task ID | Task Name | Dependencies | Status |
|---------|-----------|--------------|--------|
| S2F1 | 로그인 UI | S1S1 | 진행중 |
| S2BA1 | 구독 API | S1D1, S1D2 | 대기 |
| S2S1 | 세션 관리 | S1S1 | 대기 |

...
```

### 작성 순서

1. Stage별로 섹션 분리
2. 각 Stage 내에서 Area별로 Task 나열
3. 의존성 명시
4. 상태 추적

---

## 6. Dependency Diagram

### 시각적 의존성 표현

텍스트보다 다이어그램이 의존성을 파악하기 쉽다.

```
[S1: 개발 준비]
    S1D1 ────┬────→ S2BA1
    (DB)     │      (API)
             │
    S1S1 ────┼────→ S2F1
    (Auth)   │      (UI)
             │
    S1BI1 ───┘
    (Client)

[S2: 개발 1차]
    S2BA1 ────→ S2F1
    (API)       (UI)
         \
          ────→ S3E1
                (External)
```

### 다이어그램 읽는 법

- **화살표**: 의존 방향 (A → B: B가 A에 의존)
- **같은 행**: 병렬 진행 가능
- **세로 흐름**: 순차 진행 필요

### 병렬 작업 식별

```
        S1D1 ─────→ S2BA1
        S1S1 ─────→ S2F1    ← 병렬 가능!
        S1BI1 ────→ S2S1    ← 병렬 가능!
```

같은 Stage에서 서로 의존하지 않는 Task들은 동시에 진행할 수 있다.

---

## 7. 의존성 관리 실전 팁

### Tip 1: Stage 간 의존성 최소화

```
✅ 좋은 패턴:
S1 → S2 → S3 → S4 → S5 (단방향)

❌ 나쁜 패턴:
S2 → S1 (역방향 의존)
```

### Tip 2: 핵심 Task 먼저

의존성이 많은 Task는 빨리 완료해야 한다. 많은 Task가 기다리고 있기 때문이다.

```
S1D1 (DB 스키마) ← 10개 Task가 의존
→ 최우선 완료!
```

### Tip 3: 의존성 병목 제거

하나의 Task에 너무 많은 의존성이 몰리면 병목이 된다.

```
문제:
S1D1 ← S2BA1, S2BA2, S2BA3, S2F1, S2F2 (5개 대기)

해결:
S1D1을 S1D1a, S1D1b로 분할
→ 일부 Task는 S1D1a만 기다려도 시작 가능
```

---

## 8. 다음 단계

4편에서는 Task 생성과 의존성 관리를 살펴봤다.

- Task 분할 원칙: 단일 책임, 독립 테스트, 명확한 완료 기준
- Task ID: Stage + Area + Level
- 의존성: dependencies 속성으로 선행 Task 명시
- 순환 의존성: 절대 금지, 발견 시 즉시 해결

다음 편에서는 Task Instruction을 작성하는 방법을 살펴본다.

---

*다음 편: 5편 | Task Instruction 작성법*

---

**작성일: 2025-12-20 / 글자수: 약 4,500자 / 작성자: Claude / 프롬프터: 써니**
