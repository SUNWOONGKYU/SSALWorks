# 24편 | 웹 애플리케이션 아키텍처

---

종합 실습 프로젝트를 완료했다면, 이제 더 큰 규모의 애플리케이션을 위한 **아키텍처 설계**를 이해할 차례입니다. 아키텍처는 **건물의 설계도**와 같습니다. 집을 지을 때 먼저 설계도를 그리듯, 웹 애플리케이션도 구조를 먼저 설계해야 나중에 문제가 생기지 않습니다.

## 1. 웹 아키텍처란?

### 1-1. 아키텍처의 중요성

웹 애플리케이션 아키텍처는 **시스템의 구조와 구성 요소 간의 관계**를 정의합니다.

좋은 아키텍처가 중요한 이유:
- **확장성**: 사용자가 늘어나도 대응 가능
- **유지보수성**: 변경사항 적용이 쉬움
- **안정성**: 일부 장애가 전체에 영향 주지 않음
- **성능**: 효율적인 리소스 사용

### 1-2. 아키텍처 선택 기준

| 고려사항 | 질문 |
|----------|------|
| 규모 | 예상 사용자가 몇 명인가? |
| 복잡도 | 기능이 얼마나 복잡한가? |
| 팀 크기 | 개발자가 몇 명인가? |
| 예산 | 인프라 비용은 얼마인가? |

## 2. 모놀리식 vs 마이크로서비스

### 2-1. 모놀리식 아키텍처

**모놀리식(Monolithic)**은 모든 기능이 **하나의 애플리케이션**에 포함된 구조입니다.

```
┌─────────────────────────────────┐
│         모놀리식 앱              │
│  ┌─────┐ ┌─────┐ ┌─────┐       │
│  │사용자│ │상품 │ │주문 │       │
│  │관리 │ │관리 │ │관리 │       │
│  └─────┘ └─────┘ └─────┘       │
│  ┌─────────────────────┐       │
│  │      데이터베이스     │       │
│  └─────────────────────┘       │
└─────────────────────────────────┘
```

**장점**:
- 개발 및 배포가 단순
- 디버깅이 쉬움
- 초기 개발 속도가 빠름

**단점**:
- 규모가 커지면 복잡해짐
- 일부 수정이 전체에 영향
- 기술 스택 변경이 어려움

### 2-2. 마이크로서비스 아키텍처

**마이크로서비스**는 기능별로 **독립적인 서비스**로 분리하는 구조입니다.

```
┌────────┐  ┌────────┐  ┌────────┐
│사용자   │  │상품    │  │주문    │
│서비스   │  │서비스   │  │서비스   │
│  DB    │  │  DB    │  │  DB    │
└───┬────┘  └───┬────┘  └───┬────┘
    │          │          │
    └──────────┼──────────┘
               │
        ┌──────┴──────┐
        │  API 게이트웨이 │
        └─────────────┘
```

**장점**:
- 독립적 배포 가능
- 기술 스택 자유롭게 선택
- 장애 격리 (한 서비스 문제가 전체 영향 X)

**단점**:
- 운영 복잡도 증가
- 서비스 간 통신 오버헤드
- 데이터 일관성 관리 어려움

### 2-3. 언제 무엇을 선택할까?

| 상황 | 추천 아키텍처 |
|------|--------------|
| 스타트업/MVP | 모놀리식 |
| 소규모 팀 (1-5명) | 모놀리식 |
| 대규모 트래픽 예상 | 마이크로서비스 |
| 여러 팀 협업 | 마이크로서비스 |

## 3. 프론트엔드 아키텍처 패턴

### 3-1. MVC (Model-View-Controller)

전통적인 웹 애플리케이션 패턴입니다.

```
┌─────────┐     ┌────────────┐     ┌──────────┐
│  Model  │ ←── │ Controller │ ←── │   View   │
│ (데이터) │     │  (로직)    │     │  (화면)  │
└─────────┘     └────────────┘     └──────────┘
```

- **Model**: 데이터와 비즈니스 로직
- **View**: 사용자에게 보이는 화면
- **Controller**: Model과 View 연결

### 3-2. Flux/Redux 패턴

React 생태계에서 널리 사용되는 패턴입니다.

```
Action → Dispatcher → Store → View
   ↑                           │
   └───────────────────────────┘
```

**핵심 원칙**:
- **단방향 데이터 흐름**: 데이터가 한 방향으로만 흐름
- **단일 상태 저장소**: 모든 상태가 한 곳에 저장
- **예측 가능한 상태 변화**: 순수 함수로 상태 변경

### 3-3. 컴포넌트 기반 아키텍처

현대 프론트엔드의 표준 접근 방식입니다.

```
┌────────────────────────────────┐
│            App                 │
│  ┌────────────────────────┐   │
│  │        Header           │   │
│  │  ┌─────┐ ┌─────────┐   │   │
│  │  │Logo │ │  Nav    │   │   │
│  │  └─────┘ └─────────┘   │   │
│  └────────────────────────┘   │
│  ┌────────────────────────┐   │
│  │        Main             │   │
│  │  ┌──────┐ ┌──────────┐ │   │
│  │  │Sidebar│ │ Content  │ │   │
│  │  └──────┘ └──────────┘ │   │
│  └────────────────────────┘   │
└────────────────────────────────┘
```

## 4. 백엔드 아키텍처 패턴

### 4-1. 레이어드 아키텍처

가장 일반적인 백엔드 구조입니다.

```
┌─────────────────────────┐
│   Presentation Layer    │  ← API 엔드포인트
├─────────────────────────┤
│    Business Layer       │  ← 비즈니스 로직
├─────────────────────────┤
│  Data Access Layer      │  ← DB 접근
├─────────────────────────┤
│      Database           │
└─────────────────────────┘
```

**각 레이어의 역할**:
- **Presentation**: 요청/응답 처리, 유효성 검사
- **Business**: 핵심 비즈니스 규칙
- **Data Access**: 데이터베이스 CRUD 작업

### 4-2. 클린 아키텍처

의존성 규칙을 명확히 하는 아키텍처입니다.

```
        ┌─────────────────┐
        │    Entities     │  ← 핵심 비즈니스 규칙
        │  ┌───────────┐  │
        │  │ Use Cases │  │  ← 애플리케이션 비즈니스 규칙
        │  │ ┌───────┐ │  │
        │  │ │Adapters│ │  │  ← 인터페이스 어댑터
        │  │ │┌─────┐│ │  │
        │  │ ││Infra││ │  │  ← 프레임워크/드라이버
        │  │ │└─────┘│ │  │
        │  │ └───────┘ │  │
        │  └───────────┘  │
        └─────────────────┘
```

**핵심 원칙**: 안쪽 레이어는 바깥쪽 레이어에 의존하지 않음

### 4-3. 이벤트 기반 아키텍처

비동기 처리에 적합한 패턴입니다.

```
Producer → Message Queue → Consumer
  (이벤트    (대기열)        (처리)
   발행)
```

**사용 예시**:
- 주문 완료 → 이메일 발송
- 결제 완료 → 재고 감소
- 회원가입 → 환영 메시지 전송

## 5. 데이터베이스 아키텍처

### 5-1. 데이터베이스 선택

| 유형 | 특징 | 사용 사례 |
|------|------|----------|
| RDBMS | 관계형, ACID | 금융, 전자상거래 |
| NoSQL (Document) | 유연한 스키마 | 블로그, CMS |
| NoSQL (Key-Value) | 빠른 읽기/쓰기 | 캐시, 세션 |
| Graph DB | 관계 중심 | 소셜 네트워크 |

### 5-2. 데이터베이스 확장 전략

**수직 확장 (Scale Up)**:
- 서버 성능 향상 (CPU, RAM 추가)
- 간단하지만 한계가 있음

**수평 확장 (Scale Out)**:
- 서버 수 증가
- 더 복잡하지만 확장성 좋음

### 5-3. 읽기/쓰기 분리

```
┌──────────┐     ┌──────────┐
│  Master  │ ──► │  Slave 1 │
│  (쓰기)  │     │  (읽기)  │
└──────────┘     └──────────┘
      │          ┌──────────┐
      └────────► │  Slave 2 │
                 │  (읽기)  │
                 └──────────┘
```

## 6. 캐싱 전략

### 6-1. 캐싱이란?

자주 요청되는 데이터를 **빠른 저장소에 임시 보관**하여 성능을 향상시키는 기법입니다.

### 6-2. 캐싱 레이어

```
Client → CDN → API Server → Redis/Cache → Database
  ↑       ↑        ↑           ↑
브라우저  에지    서버        캐시        원본
캐시    캐시    캐시        레이어      데이터
```

### 6-3. 캐싱 패턴

**Cache-Aside (Lazy Loading)**:
1. 캐시 확인
2. 없으면 DB에서 조회
3. 캐시에 저장
4. 결과 반환

**Write-Through**:
1. 데이터를 캐시와 DB에 동시 저장
2. 일관성 보장

## 7. API 디자인

### 7-1. RESTful API 원칙

```
GET    /users        # 사용자 목록 조회
GET    /users/1      # 특정 사용자 조회
POST   /users        # 사용자 생성
PUT    /users/1      # 사용자 수정
DELETE /users/1      # 사용자 삭제
```

### 7-2. API 버저닝

```
# URL 버저닝
/api/v1/users
/api/v2/users

# 헤더 버저닝
Accept: application/vnd.myapi.v1+json
```

### 7-3. GraphQL

REST의 대안으로, 클라이언트가 필요한 데이터만 요청할 수 있습니다.

```graphql
query {
  user(id: 1) {
    name
    email
    posts {
      title
    }
  }
}
```

## 8. 배포 아키텍처

### 8-1. 단일 서버

가장 간단한 구조입니다.

```
User → Server (Web + App + DB)
```

### 8-2. 로드 밸런서 + 다중 서버

```
         ┌────────────┐
         │Load Balancer│
         └─────┬──────┘
       ┌───────┼───────┐
       ▼       ▼       ▼
    Server1 Server2 Server3
       │       │       │
       └───────┼───────┘
               ▼
           Database
```

### 8-3. 컨테이너 오케스트레이션 (Kubernetes)

```
┌──────────────────────────────────┐
│           Kubernetes             │
│  ┌─────────────────────────┐    │
│  │        Pod 1             │    │
│  │  Container A, Container B│    │
│  └─────────────────────────┘    │
│  ┌─────────────────────────┐    │
│  │        Pod 2             │    │
│  │  Container A, Container B│    │
│  └─────────────────────────┘    │
└──────────────────────────────────┘
```

## 핵심 정리

| 아키텍처 | 적합한 상황 | 복잡도 |
|----------|------------|--------|
| 모놀리식 | 초기 스타트업, 소규모 | 낮음 |
| 마이크로서비스 | 대규모, 다양한 팀 | 높음 |
| 서버리스 | 이벤트 기반, 가변적 트래픽 | 중간 |

좋은 아키텍처는 **현재 요구사항을 충족**하면서 **미래 확장도 고려**해야 합니다. 처음부터 완벽한 아키텍처를 만들 필요는 없습니다. **점진적으로 발전**시켜 나가는 것이 현실적인 접근 방법입니다. 다음 편에서는 클라우드와 서버리스에 대해 알아보겠습니다.

---

**작성일: 2025-01-01 / 수정일: 2025-12-20 / 글자수: 약 5,700자 / 작성자: Claude / 프롬프터: 써니**
