# 에러 핸들링 패턴

## 핵심 요약

try-catch로 감싸고 의미 있는 에러 메시지를 반환하세요. 개발자용 로그(console.error)와 사용자용 메시지를 구분하세요. 민감한 정보는 에러 메시지에 포함하지 마세요.

## 왜 에러 핸들링이 중요한가?

### 에러 핸들링 없이 vs 있이

```
❌ 에러 핸들링 없이:
- 앱이 갑자기 멈춤
- 사용자는 무슨 문제인지 모름
- 개발자도 원인 파악 어려움
- 민감한 정보 노출 위험

✅ 에러 핸들링 있이:
- 앱이 계속 동작
- 사용자에게 친절한 안내
- 개발자가 로그로 원인 파악
- 보안 유지
```

### 에러 핸들링의 목적

| 목적 | 설명 |
|------|------|
| 안정성 | 에러가 발생해도 앱 계속 동작 |
| 사용자 경험 | 친절한 에러 메시지 제공 |
| 디버깅 | 문제 원인 파악을 위한 로깅 |
| 보안 | 민감한 정보 노출 방지 |

## 기본 에러 핸들링 패턴

### 1. try-catch 기본

```javascript
// ❌ 에러 핸들링 없음
async function login(email, password) {
  const { data } = await supabase.auth.signInWithPassword({
    email, password
  });
  return data;
}

// ✅ 에러 핸들링 있음
async function login(email, password) {
  try {
    const { data, error } = await supabase.auth.signInWithPassword({
      email, password
    });

    if (error) {
      throw error;
    }

    return { success: true, data };
  } catch (error) {
    console.error('로그인 실패:', error);
    return {
      success: false,
      message: '로그인에 실패했습니다. 이메일과 비밀번호를 확인해주세요.'
    };
  }
}
```

### 2. 사용자용 vs 개발자용 메시지

```javascript
async function submitForm(formData) {
  try {
    const response = await fetch('/api/submit', {
      method: 'POST',
      body: JSON.stringify(formData)
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    return { success: true };
  } catch (error) {
    // 개발자용: 상세한 기술 정보
    console.error('폼 제출 실패:', {
      error: error.message,
      stack: error.stack,
      formData: { ...formData, password: '[REDACTED]' }  // 민감정보 제외
    });

    // 사용자용: 친절하고 이해하기 쉬운 메시지
    return {
      success: false,
      message: '요청을 처리하지 못했습니다. 잠시 후 다시 시도해주세요.'
    };
  }
}
```

### 3. 에러 유형별 처리

```javascript
async function fetchData(endpoint) {
  try {
    const response = await fetch(endpoint);

    if (!response.ok) {
      switch (response.status) {
        case 400:
          throw new Error('잘못된 요청입니다.');
        case 401:
          throw new Error('로그인이 필요합니다.');
        case 403:
          throw new Error('접근 권한이 없습니다.');
        case 404:
          throw new Error('요청한 데이터를 찾을 수 없습니다.');
        case 500:
          throw new Error('서버 오류가 발생했습니다.');
        default:
          throw new Error('알 수 없는 오류가 발생했습니다.');
      }
    }

    return await response.json();
  } catch (error) {
    console.error('API 호출 실패:', error);
    throw error;  // 상위로 전파
  }
}
```

## Supabase 에러 핸들링

### Auth 에러 처리

```javascript
async function handleAuth(email, password) {
  try {
    const { data, error } = await supabase.auth.signInWithPassword({
      email, password
    });

    if (error) {
      // Supabase 에러 코드별 처리
      switch (error.message) {
        case 'Invalid login credentials':
          return { error: '이메일 또는 비밀번호가 올바르지 않습니다.' };
        case 'Email not confirmed':
          return { error: '이메일 인증이 필요합니다. 메일함을 확인해주세요.' };
        case 'User not found':
          return { error: '등록되지 않은 계정입니다.' };
        default:
          console.error('Auth 에러:', error);
          return { error: '로그인 중 오류가 발생했습니다.' };
      }
    }

    return { data };
  } catch (error) {
    console.error('예상치 못한 에러:', error);
    return { error: '네트워크 오류가 발생했습니다.' };
  }
}
```

### Database 에러 처리

```javascript
async function insertData(tableName, data) {
  try {
    const { data: result, error } = await supabase
      .from(tableName)
      .insert(data)
      .select();

    if (error) {
      // PostgreSQL 에러 코드별 처리
      if (error.code === '23505') {
        return { error: '이미 존재하는 데이터입니다.' };
      }
      if (error.code === '23503') {
        return { error: '참조하는 데이터가 존재하지 않습니다.' };
      }
      if (error.code === '42501') {
        return { error: '권한이 없습니다.' };
      }

      console.error('DB 에러:', error);
      return { error: '데이터 저장에 실패했습니다.' };
    }

    return { data: result };
  } catch (error) {
    console.error('DB 작업 실패:', error);
    return { error: '데이터베이스 연결에 실패했습니다.' };
  }
}
```

## UI 에러 표시 패턴

### 에러 메시지 표시

```javascript
function showError(message) {
  const errorDiv = document.getElementById('error-message');
  errorDiv.textContent = message;
  errorDiv.classList.remove('hidden');

  // 5초 후 자동 숨김
  setTimeout(() => {
    errorDiv.classList.add('hidden');
  }, 5000);
}

// 사용
async function handleSubmit() {
  const result = await submitForm(formData);

  if (!result.success) {
    showError(result.message);
  }
}
```

### 로딩 + 에러 상태 관리

```javascript
async function loadData() {
  const container = document.getElementById('data-container');
  const loading = document.getElementById('loading');
  const error = document.getElementById('error');

  try {
    // 로딩 시작
    loading.classList.remove('hidden');
    error.classList.add('hidden');
    container.classList.add('hidden');

    const data = await fetchData('/api/data');

    // 성공
    container.innerHTML = renderData(data);
    container.classList.remove('hidden');
  } catch (err) {
    // 에러
    error.textContent = err.message;
    error.classList.remove('hidden');
  } finally {
    // 로딩 종료
    loading.classList.add('hidden');
  }
}
```

## 전역 에러 핸들링

### window.onerror

```javascript
// 처리되지 않은 에러 캐치
window.onerror = function(message, source, lineno, colno, error) {
  console.error('전역 에러:', {
    message,
    source,
    lineno,
    colno,
    stack: error?.stack
  });

  // 에러 리포팅 서비스로 전송 (선택)
  // sendErrorReport({ message, source, lineno, error });

  return false;  // 기본 에러 처리도 실행
};
```

### Promise rejection 처리

```javascript
// 처리되지 않은 Promise 에러 캐치
window.addEventListener('unhandledrejection', function(event) {
  console.error('처리되지 않은 Promise 에러:', event.reason);

  // 사용자에게 알림 (선택)
  // showError('예상치 못한 오류가 발생했습니다.');

  event.preventDefault();
});
```

## 에러 로깅 패턴

### 구조화된 로깅

```javascript
function logError(context, error, additionalInfo = {}) {
  const errorLog = {
    timestamp: new Date().toISOString(),
    context,
    message: error.message,
    stack: error.stack,
    ...additionalInfo
  };

  console.error(JSON.stringify(errorLog, null, 2));

  // 프로덕션에서는 로깅 서비스로 전송
  if (process.env.NODE_ENV === 'production') {
    // sendToLoggingService(errorLog);
  }
}

// 사용
try {
  await processOrder(orderId);
} catch (error) {
  logError('주문 처리', error, { orderId, userId });
}
```

## 민감 정보 보호

### 에러에 민감 정보 포함하지 않기

```javascript
// ❌ 나쁜 예
catch (error) {
  console.error(`로그인 실패 - 이메일: ${email}, 비밀번호: ${password}`);
  return { error: `비밀번호 '${password}'가 올바르지 않습니다.` };
}

// ✅ 좋은 예
catch (error) {
  console.error('로그인 실패:', { email, errorCode: error.code });
  return { error: '이메일 또는 비밀번호가 올바르지 않습니다.' };
}
```

### 사용자에게 기술 정보 노출하지 않기

```javascript
// ❌ 나쁜 예
catch (error) {
  return { error: error.stack };  // 스택 트레이스 노출
}

// ✅ 좋은 예
catch (error) {
  console.error('서버 에러:', error);  // 개발자용 로그
  return { error: '서버 오류가 발생했습니다.' };  // 사용자용 메시지
}
```

## Claude Code에게 요청하기

### 에러 핸들링 추가 요청

```
"이 함수에 에러 핸들링 추가해줘:
- try-catch로 감싸기
- 사용자용 메시지와 개발자용 로그 분리
- Supabase 에러 코드별 처리"
```

### 에러 분석 요청

```
"이 에러 메시지 분석해줘:
[에러 메시지 붙여넣기]

원인이 뭐고 어떻게 해결해?"
```

## 체크리스트

### 에러 핸들링 체크리스트

- [ ] 모든 async 함수에 try-catch 있는가?
- [ ] Supabase 호출 후 error 체크하는가?
- [ ] 사용자용 메시지가 친절한가?
- [ ] 개발자용 로그가 충분한가?
- [ ] 민감 정보가 노출되지 않는가?
- [ ] 전역 에러 핸들러 설정했는가?

## 주의사항

- 에러를 무시하고 빈 catch 블록 사용하지 않기
- 사용자에게 기술적 에러 메시지 그대로 보여주지 않기
- 민감한 정보(비밀번호, 토큰 등) 로깅하지 않기
- 프로덕션에서 console.log 남용하지 않기
- 에러 발생 시 사용자가 다음 행동을 알 수 있도록 안내

